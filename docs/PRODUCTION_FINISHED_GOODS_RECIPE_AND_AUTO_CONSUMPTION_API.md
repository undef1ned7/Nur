# Production / Finished Goods
## Рецепт (сырьё + расход на 1 товар) + авто-списание сырья на backend

Документ описывает изменения для backend, чтобы:

- при создании готового товара сохранялся **рецепт**: не только `id` сырья, но и **расход на 1 единицу товара** (`qty_per_unit`);
- рецепт можно было **редактировать**: добавлять/удалять сырьё, менять `qty_per_unit`;
- **сырьё не списывалось на фронте** (никаких PATCH `/main/items-make/{id}/` из UI), а **backend автоматически** делал минус/плюс в зависимости от изменения количества товара и/или рецепта.

---

## 1) Термины

- **ItemsMake**: сырьё (endpoint на фронте уже есть `GET /main/items-make/`).
- **Finished Good / Product**: готовый товар.
- **Рецепт**: список сырья с нормой расхода на 1 ед. товара:

```json
[
  { "id": "7", "qty_per_unit": 0.25 },
  { "id": "9", "qty_per_unit": 0.01 }
]
```

Где:
- `id` — это `items_make.id`
- `qty_per_unit` — расход сырья **на 1 единицу** готового товара

---

## 2) Хранение данных (БД)

### 2.1 Таблица рецепта (Many-to-Many с атрибутом)
Рекомендуемая таблица: `product_recipe_items` (название можно другое).

Поля:
- `id` (PK)
- `product_id` (FK -> products.id, CASCADE)
- `item_make_id` (FK -> items_make.id)
- `qty_per_unit` DECIMAL(12,3) NOT NULL, CHECK (qty_per_unit > 0)
- `created_at`, `updated_at`

Ограничения:
- `UNIQUE(product_id, item_make_id)` — один материал не должен повторяться в рецепте товара.

---

## 3) API (контракты)

### 3.1 Создание товара + сохранение рецепта + авто-списание сырья (атомарно)
Текущий фронт создаёт товар через:
- `POST /main/products/create-manual/`

Нужно расширить этот endpoint: принимать `recipe` и выполнять **автоматическое списание сырья**.

#### Request

```json
{
  "name": "Буханка хлеба",
  "barcode": "1234567890",
  "brand_name": "NUR",
  "category_name": "Хлеб",
  "price": 120,
  "quantity": 100,
  "client": 15,
  "purchase_price": "110",
  "stock": false,
  "recipe": [
    { "id": "7", "qty_per_unit": 0.250 },
    { "id": "9", "qty_per_unit": 0.010 }
  ]
}
```

#### Семантика (обязательная)
- Backend должен выполнить транзакцию:
  - создать продукт
  - сохранить рецепт (upsert в `product_recipe_items`)
  - списать сырьё по формуле:

\[
required(item) = qty\_per\_unit(item) \times product.quantity
\]

  - если сырья не хватает — вернуть 400 и **ничего не создавать/не списывать**.

#### Валидация
- `recipe[]`:
  - `id` должен существовать в `items_make`
  - `qty_per_unit` число, \(> 0\)
  - максимум 3 знака после запятой (backend округляет или валидирует)
  - запрет дублей `id` в одном запросе
- `quantity` (готового товара) число, \(\ge 0\)

#### Response (рекомендуется)
Возвращать рецепт, чтобы UI мог сразу показать сохранённые значения:

```json
{
  "id": 501,
  "name": "Буханка хлеба",
  "quantity": 100,
  "recipe": [
    { "id": 7, "name": "Мука", "qty_per_unit": 0.25 },
    { "id": 9, "name": "Дрожжи", "qty_per_unit": 0.01 }
  ]
}
```

---

### 3.2 Получение товара (для редактирования рецепта)
Нужно, чтобы detail продукта возвращал рецепт с нормами:

- `GET /main/products/{productId}/` (или ваш существующий detail endpoint)

Response должен содержать:
- `recipe: [{ id, qty_per_unit, name? }]`

---

### 3.3 Редактирование товара: авто-минус/плюс сырья при изменениях (дельта)
Для UI редактирования удобно сделать **один** endpoint: PATCH продукта, который умеет:
- менять `quantity`
- менять `recipe` (полная замена списка)
- и корректировать остатки сырья **на разницу** между старым и новым состоянием.

#### Endpoint
- `PATCH /main/products/{productId}/`

#### Request (можно менять одно или оба)

```json
{
  "quantity": 120,
  "recipe": [
    { "id": "7", "qty_per_unit": 0.200 },
    { "id": "11", "qty_per_unit": 0.050 }
  ]
}
```

#### Семантика дельты (ключевая часть)
Backend должен:

1) Прочитать **старые** значения:
- `old_quantity`
- `old_recipe` (map item_make_id -> qty_per_unit)

2) Сформировать **новые** значения:
- `new_quantity` (если не передали — old)
- `new_recipe` (если не передали — old)

3) Посчитать для каждого сырья требование “сколько должно быть списано”:

\[
requiredOld(id) = oldQtyPerUnit(id) \times oldQuantity
\]
\[
requiredNew(id) = newQtyPerUnit(id) \times newQuantity
\]
\[
delta(id) = requiredNew(id) - requiredOld(id)
\]

Где:
- `delta > 0` ⇒ нужно **досписать** сырьё (`items_make.quantity -= delta`)
- `delta < 0` ⇒ нужно **вернуть** сырьё (`items_make.quantity += abs(delta)`)

4) Обновить рецепт (upsert/delete строк в `product_recipe_items`) и product.quantity.

#### Правила безопасности
- Все расчёты и изменения остатков сырья должны быть **атомарны** (транзакция).
- Для конкурентной безопасности: блокировать строки сырья `SELECT ... FOR UPDATE` (или аналог).
- Если для какого-то сырья `delta > 0` и остатка не хватает:
  - вернуть 400
  - откатить транзакцию (никаких частичных списаний).

#### Важное бизнес-замечание
Авто-«плюс» сырья при уменьшении количества готового товара означает “мы как бы разобрали продукт обратно на сырьё”.
Если по бизнес-логике это нельзя (потому что товар уже произведён/продан), то нужно ограничение:
- запретить уменьшение `quantity` после определённого статуса, или
- вести не `product.quantity`, а отдельный документ “производство партии”.

Но в рамках текущего запроса ожидается именно автоматический плюс/минус при редактировании.

---

## 4) Backward compatibility (чтобы старые клиенты не сломались)
Сейчас фронт отправляет `item_make: [id, id, ...]` без количества.

Рекомендация:
- продолжить принимать `item_make` (как раньше),
- но если `recipe` отсутствует:
  - либо **не сохранять рецепт** (и вернуть `recipe: []`),
  - либо создать рецепт с `qty_per_unit = 1.000` (нежелательно, но совместимо).

При одновременной передаче `item_make` и `recipe`:
- приоритет у `recipe`.

---

## 5) Что нужно поменять на фронте (коротко, для согласования)
Сейчас в `FinishedGoods.jsx` перед созданием товара фронт делает списание сырья через `consumeItemsMake()` (GET/PATCH по `/main/items-make/{id}/`).

После внедрения backend-авто-списания:
- фронт должен **перестать** вызывать списание сырья вручную;
- при создании/редактировании отправлять `recipe` вместе с продуктом:
  - `recipe: [{ id: materialId, qty_per_unit: quantityPerUnit }]`

---

## 6) Acceptance criteria
- Создание товара с `recipe` сохраняет рецепт и списывает сырьё автоматически.
- PATCH товара с изменением `quantity` и/или `recipe` корректно делает минус/плюс сырья по дельте.
- Нельзя уйти в минус по сырью: при нехватке — 400 и откат.
- GET товара возвращает рецепт с `qty_per_unit`.

